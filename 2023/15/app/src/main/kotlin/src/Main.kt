/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}

fun solveP1(lines: List<String>) {
    val input = lines.filter { it.isNotEmpty()}
    val steps = input.joinToString("").split(",")

    steps.sumOf { step ->
        hash(step)
    }.also { println("P1: $it") }
}

fun solveP2(lines: List<String>) {
    val input = lines.filter { it.isNotEmpty()}
    val steps = input.joinToString("").split(",")

    val commands = processRawCommands(steps)
    val boxes = mutableMapOf<Long, MutableList<Lens>>()
    (0.. 255).forEach { boxes.put(it.toLong(), mutableListOf()) }

    commands.forEach { cmd ->
        val operationBox = hash(cmd.label)
        val box = boxes[operationBox]!!
        when(cmd.op) {
            Operation.EQUAL -> {
                val idxExistingBox = box.indexOfFirst { it.label == cmd.label }
                if (idxExistingBox == -1) {
                    // not found... put it in the end
                    box.add(Lens(cmd.label, cmd.value!!))
                } else {
                    box[idxExistingBox] = Lens(cmd.label, cmd.value!!)
                }
            }
            Operation.MINUS -> {
                // remove lens from the box with label if exists
                box.removeIf { it.label == cmd.label }
            }
        }
    }

    boxes.entries.sumOf { entry ->
        entry.value.foldIndexed(0L) { idx, acc, lens ->
            acc + ((1 + entry.key) * (idx + 1) * lens.focusLen)
        }
    }.also { println("P2 $it") }
}

data class Step(val label: String, val op: Operation, val value: Int? = null)
data class Lens(val label: String, val focusLen: Int)
enum class Operation {
    EQUAL,
    MINUS;

    companion object {
        fun fromChar(char: Char): Operation {
            return when(char) {
                '=' -> EQUAL
                '-' -> MINUS
                else -> TODO() // should not happen
            }
        }
    }
}

private fun hash(step: String): Long {
    return step.fold(0L) { acc, char ->
        ((acc + char.code) * 17) % 256
    }
}

private fun processRawCommands(steps: List<String>) = steps.map { step ->
    val lastChar = step.last()
    if (lastChar.isDigit()) {
        //it's an equal Operation!!
        val splitCmd = step.split("=")
        Step(splitCmd.first(), Operation.EQUAL, splitCmd.last().toInt())
    } else {
        // minus op
        val splitCmd = step.split("-")
        Step(splitCmd.first(), Operation.MINUS)
    }
}
