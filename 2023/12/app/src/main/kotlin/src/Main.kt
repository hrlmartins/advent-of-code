/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}
fun solveP1(lines: List<String>) {
    val records = lines.map {
        val splitData = it.split(" ")
        Record(splitData.first(), splitData.last().split(",").map { it.toInt() })
    }

    records.sumOf {
        solve(it, it.springs.toMutableList(), it.damageRecords.toMutableList(), 0, 0, 0, mutableMapOf())
    }.also { println("P1: $it") }


}

fun solveP2(lines: List<String>) {
    val records = lines.map {
        val splitData = it.split(" ")
        Record(splitData.first(), splitData.last().split(",").map { it.toInt() })
    }

    val extendedRecords = records.map { r ->
        val springsRepeated = List(4) { r.springs + "?" }.joinToString("") + r.springs
        val listsRepeated = List(5) { r.damageRecords }.flatMap { it }

        Record(springsRepeated, listsRepeated)
    }

    extendedRecords.sumOf {
        solve(it, it.springs.toMutableList(), it.damageRecords.toMutableList(), 0, 0,0, mutableMapOf())
    }.also { println("P2: $it") }
}




private fun checkSolution(damageRecords: List<Int>, solution: List<Char>): Boolean {
    val splitSol = solution.joinToString("").split(".").filter { it.contains("#") }


    return splitSol.size == damageRecords.size &&
            damageRecords.zip(splitSol).all { (original, generated) -> original == generated.length }
}

private fun solve(
        origRecord: Record,
        solution: MutableList<Char>,
        dmgRecord: List<Int>,
        idx: Int,
        dmgRecordIdx: Int,
        currentGroupLen: Int,
        mem: MutableMap<Key, Long>): Long {

    if (idx == origRecord.springs.length) {
        // check solution, return 0 if nope, return 1 if yes
        return if (checkSolution(origRecord.damageRecords, solution) && dmgRecord.all { it == 0 })  {
            1L
        } else {
            0L
        }
    }

    if (idx >= solution.size) return 0L

    if(dmgRecordIdx < dmgRecord.size) {
        val key = Key(idx, dmgRecordIdx, solution[idx], dmgRecord[dmgRecordIdx])
        if (mem.containsKey(key)) {
            return mem[key]!!
        }
    }

    var brokenGroupCount = if(dmgRecordIdx < dmgRecord.size) dmgRecord[dmgRecordIdx] else null
    val currentSpring = solution[idx]
    return when (currentSpring) {
        '.' -> {
            val res = if (currentGroupLen > 0) {
                if (brokenGroupCount == 0) {
                    solve(origRecord, solution, dmgRecord, idx + 1, dmgRecordIdx + 1, 0, mem)
                } else {
                    0L
                }

            } else {
                solve(origRecord, solution, dmgRecord, idx + 1, dmgRecordIdx, currentGroupLen, mem)
            }
            if(dmgRecordIdx < dmgRecord.size) {
                val key = Key(idx, dmgRecordIdx, solution[idx], dmgRecord[dmgRecordIdx])
                mem[key] = res
            }

            res
        }
        '#' -> {
            // decrease the current broken group number
            if (brokenGroupCount == null || brokenGroupCount == 0) {
                if(dmgRecordIdx < dmgRecord.size) {
                    val key = Key(idx, dmgRecordIdx, solution[idx], dmgRecord[dmgRecordIdx])
                    mem[key] = 0L
                }
                return 0L
            }


            brokenGroupCount -= 1
            val newDmgRecord = dmgRecord.toMutableList()
            newDmgRecord[dmgRecordIdx] = brokenGroupCount
            val res = solve(origRecord, solution, newDmgRecord, idx + 1, dmgRecordIdx, currentGroupLen + 1, mem)
            if(dmgRecordIdx < dmgRecord.size) {
                val key = Key(idx, dmgRecordIdx, solution[idx], dmgRecord[dmgRecordIdx])
                mem[key] = res
            }

            res
        }
        else -> {
            // we have a question mark!!!!
            // Now we start backtracking and testing
            listOf('.', '#').sumOf {
                solution[idx] = it
                val res = solve(origRecord, solution, dmgRecord, idx, dmgRecordIdx, currentGroupLen, mem)
                solution[idx] = '?'
                res
            }
        }
    }
}

data class Record(val springs: String, val damageRecords: List<Int>)

data class Key(val idx: Int, val dmgRecordsIdx: Int, val currentPool: Char, val remainingDmgLen: Int)