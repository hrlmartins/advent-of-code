/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}

fun solveP1(lines: List<String>) {

    val seeds = getSeeds(lines)

    val almanacList = lines.subList(2, lines.size)
    val categoryMaps = extractCategoryMaps(almanacList)

    seeds.minOf { seed ->
        var changingSource = seed
        categoryMaps.forEach { categoryMap ->
            val suitableRange = categoryMap.firstOrNull { range ->
                val diff = changingSource - range.sourceStart
                diff >= 0 && diff < range.size
            }

            suitableRange?.let {
                val diff = changingSource - it.sourceStart
                changingSource = it.destinationStart + diff
            }
        }

        changingSource
    }.also { println("lowest location number $it") }

}

fun solveP2(lines: List<String>) {
    val seeds = getSeeds(lines)

    val almanacList = lines.subList(2, lines.size)
    val categoryMaps = extractCategoryMaps(almanacList)

    seeds.chunked(2).minOf {
        (it[0]until it[0]+it[1]).minOf { seed ->
            var changingSource = seed
            categoryMaps.forEach { categoryMap ->
                val suitableRange = categoryMap.firstOrNull { range ->
                    val diff = changingSource - range.sourceStart
                    diff >= 0 && diff < range.size
                }

                suitableRange?.let {
                    val diff = changingSource - it.sourceStart
                    changingSource = it.destinationStart + diff
                }
            }

            changingSource
        }
    }.also { println("p2: $it") }
}

data class Range(val destinationStart: Long, val sourceStart: Long, val size: Long)

private fun getSeeds(lines: List<String>): List<Long> {
    val numberPattern = """(\d+)""".toRegex()
    return numberPattern.findAll(
            lines.first().split(":").last()
    ).map { it.value.toLong() }.toList()
}

private fun extractCategoryMaps(almanacList: List<String>): List<List<Range>> {
    val rangeList = almanacList.foldIndexed(mutableListOf<List<Range>>()) { idx, acc, line ->
        if (line.contains("map")) {
            var mapDataIdx = idx + 1
            val listOfRanges = mutableListOf<Range>()
            while (
                    mapDataIdx < almanacList.size &&
                    !almanacList.get(mapDataIdx).contains("map") &&
                    almanacList.get(mapDataIdx).isNotEmpty()
            ) {
                // first is destination range start
                // second is source range start
                // third is range
                val numbers = almanacList.get(mapDataIdx).split(" ").map { it.toLong() }
                listOfRanges.add(Range(numbers[0], numbers[1], numbers[2]))
                mapDataIdx++
            }

            acc.add(listOfRanges)
        }

        acc
    }
    return rangeList
}
