/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

import kotlin.math.abs

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}
fun solveP1(lines: List<String>) {
    var galaxies = readGalaxies(lines)
    // expand rows
    galaxies = expandUniverse(lines, galaxies, 1)

    val visited = mutableSetOf<Coords>()
    galaxies.sumOf { g1 ->
        val res = galaxies.sumOf { g2 ->
            if (g1 == g2 || visited.contains(g2)) return@sumOf 0L

            val dist = manhattanDist(g1, g2)

            dist.toLong()
        }
        visited.add(g1)

        res
    }.also { println("P1: $it") }
}

fun solveP2(lines: List<String>) {
    var galaxies = readGalaxies(lines)
    // expand rows
    galaxies = expandUniverse(lines, galaxies, 1000000-1)

    val visited = mutableSetOf<Coords>()
    galaxies.sumOf { g1 ->
        val res = galaxies.sumOf { g2 ->
            if (g1 == g2 || visited.contains(g2)) return@sumOf 0L

            val dist = manhattanDist(g1, g2)

            dist.toLong()
        }
        visited.add(g1)

        res
    }.also { println("P2: $it") }
}

data class Coords(val x: Int, val y: Int)

private fun manhattanDist(g1: Coords, g2: Coords) = abs(g1.x - g2.x) + abs(g1.y - g2.y)

private fun readGalaxies(lines: List<String>): Set<Coords> {
    val galaxiesMap = mutableSetOf<Coords>()
    lines.forEachIndexed { yIdx, row ->
        row.forEachIndexed { xIdx, c ->
            if (c == '#') {
                galaxiesMap.add(Coords(xIdx, yIdx))
            }
        }
    }

    return galaxiesMap
}

private fun expandUniverse(lines: List<String>, galaxies: Set<Coords>, expandBy: Int): Set<Coords> {
    val tmpGalaxies = galaxies.toMutableList()
    var yDelta = 0
    lines.forEachIndexed  { yIndex, line ->
        if (line.all { it == '.' }) {
            // every galaxy below the line has to be updated
            tmpGalaxies.forEachIndexed { idx, c ->
                if (c.y > yIndex + yDelta) {
                    tmpGalaxies[idx] = c.copy(y = c.y + expandBy)
                }
            }

            yDelta += expandBy
        }
    }
    // expand coluns now
    val columnSize = lines.first().length
    var xDelta = 0
    (0 until columnSize).forEach{ xIndex ->

        val colString = lines.fold("") { acc, line -> acc + line[xIndex] }

        if (colString.all { it == '.' }) {
            // every galaxy to the right of the column has to be updated
            tmpGalaxies.forEachIndexed { idx, c ->
                if (c.x > xIndex + xDelta) {
                    tmpGalaxies[idx] = c.copy(x = c.x + expandBy)
                }
            }

            xDelta += expandBy
        }
    }

    return tmpGalaxies.toSet()
}

private fun printUniverse(galaxies: Set<Coords>) {
    val maxX = galaxies.maxOf { it.x }
    val maxY = galaxies.maxOf { it.y }

    (0..maxY).forEach { yIdx ->
        (0..maxX).forEach { xIdx ->
            if (galaxies.contains(Coords(xIdx, yIdx))) {
                print("#")
            } else {
                print(".")
            }
        }
        println()
    }

    println()
}
