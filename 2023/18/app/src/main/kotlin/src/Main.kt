/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

import java.util.*
import kotlin.math.absoluteValue

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}

fun solveP1(lines: List<String>) {
    val pattern = """(\w+)\s*(\d+)\s*\(#(\w+)\)""".toRegex()
    val commands = processInput(lines.filter { it.isNotEmpty() }, pattern)

    var start = Coords(0, 0)
    val usedGround = mutableSetOf(start.copy())

    commands.forEach { command ->
        for (i in 0 until command.amount) {
            when(command.dir) {
                Direction.UP -> {
                    start = start.copy(y = start.y - 1)
                    usedGround.add(start)
                }
                Direction.DOWN -> {
                    start = start.copy(y = start.y + 1)
                    usedGround.add(start)
                }
                Direction.RIGHT -> {
                    start = start.copy(x = start.x + 1)
                    usedGround.add(start)
                }
                Direction.LEFT -> {
                    start = start.copy(x = start.x - 1)
                    usedGround.add(start)
                }
            }
        }
    }

    fillGaps(1, 1, usedGround)
    println("P1: ${usedGround.size}")
}

fun solveP2(lines: List<String>) {
    val pattern = """(\w+)\s*(\d+)\s*\(#(\w+)\)""".toRegex()
    val commands = processComplexInput(lines.filter { it.isNotEmpty() }, pattern)

    val vertices = mutableListOf<Coords>()
    var start = Coords(0, 0)
    var perimeter = 0L

    vertices.add(start)
    commands.forEach { command ->
        start = when(command.dir){
            Direction.UP -> {
                start.copy(x = start.x, y = start.y - command.amount)
            }
            Direction.DOWN -> {
                start.copy(x = start.x, y = start.y + command.amount)
            }
            Direction.RIGHT -> {
                start.copy(x = start.x + command.amount, y = start.y)
            }
            Direction.LEFT -> {
                start.copy(x = start.x - command.amount, y = start.y)
            }
        }

        vertices.add(start)
        perimeter += command.amount
    }

    vertices.add(Coords(0, 0)) // by the formula it rounds back and end in the first node

    val sumDeterminants = vertices.windowed(2, 1).sumOf { (first, second) ->
        (first.x * second.y) - (second.x * first.y)
    }.absoluteValue

    val shoeArea = sumDeterminants / 2
    // picks theorem we want the i. The A was given by shoelace formula (BIG BRAIN MATH XD) https://en.wikipedia.org/wiki/Pick%27s_theorem
    println("P2: ${shoeArea - (perimeter / 2) + 1 + perimeter}")
}


// Somehow odd/even was not working. Went brute force!
private fun fillGaps(yMin: Int, xMin: Int, usedGround: MutableSet<Coords>) {
    val queue: Queue<Coords> = LinkedList()
    val startPointInside = Coords(xMin.toLong(), yMin.toLong())
    queue.add(startPointInside)
    while (queue.isNotEmpty()) {
        val newPoint = queue.poll()
        if (!usedGround.contains(newPoint)) {
            usedGround.add(newPoint)
            listOf(Pair(0, 1), Pair(1, 0), Pair(0, -1), Pair(-1, 0)).forEach {
                queue.add(newPoint.copy(x = newPoint.x + it.first, y = newPoint.y + it.second))
            }
        }
    }
}

private fun printGround(xMin: Int, xMax: Int, yMin: Int, yMax: Int, nodes: Set<Coords>) {
    (yMin .. yMax).forEach {y ->
        (xMin .. xMax).forEach { x ->
            if (nodes.contains(Coords(x.toLong(), y.toLong()))) {
                print("#")
            } else {
                print(".")
            }
        }
        println()
    }

    println()
}

data class Coords(val x: Long, val y: Long)
data class Command(val dir: Direction, val amount: Long, val colorCode: String? = null)
enum class Direction {
    UP,
    DOWN,
    RIGHT,
    LEFT;

    companion object {
        fun fromChar(char: Char): Direction {
            return when(char) {
                'R','0' -> RIGHT
                'L','2' -> LEFT
                'U','3' -> UP
                'D','1' -> DOWN
                else -> TODO()
            }
        }
    }
}

private fun processInput(lines: List<String>, pattern: Regex): List<Command> {
    return lines.map {
        val (dir, amount, code) = pattern.find(it)!!.destructured
        Command(Direction.fromChar(dir.get(0)), amount.toLong(), code)
    }
}

private fun processComplexInput(lines: List<String>, pattern: Regex): List<Command> {
    return lines.map {
        val (_, _, code) = pattern.find(it)!!.destructured
        // lol, now the command is the hexadecimal
        val amount = code.slice(0..4).toLong(16)
        val dir = code.last()
        Command(Direction.fromChar(dir), amount, code)
    }
}