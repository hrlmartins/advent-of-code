/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}

fun solveP1(lines: List<String>) {
    val directionList = lines.first().map { if (it == 'L') Direction.LEFT else Direction.RIGHT }
    val network = buildNetwork(lines.filter { it.isNotEmpty() })

    val destination = "ZZZ"
    var currSpot = network["AAA"]
    var count = 0

    while (currSpot!!.source != destination) {
        val goTo = directionList[count % directionList.size]

        when(goTo) {
            Direction.LEFT -> currSpot = network[currSpot.left]
            Direction.RIGHT -> currSpot = network[currSpot.right]
        }
        count++
    }

    println("P1: $count")
}

fun solveP2(lines: List<String>) {
    val directionList = lines.first().map { if (it == 'L') Direction.LEFT else Direction.RIGHT }
    val network = buildNetwork(lines.filter { it.isNotEmpty() })

    // All the starting spots
    var startingSpots = network.values.filter { it.source.endsWith("A")}

    val stepsTakenPerSource = startingSpots.map { start ->
        var currSpot = start
        var count = 0L
        while(!atFinishLine(currSpot)) {
            val goTo = directionList[(count % directionList.size).toInt()]

            when(goTo) {
                Direction.LEFT -> currSpot = network[currSpot.left]!!
                Direction.RIGHT -> currSpot = network[currSpot.right]!!
            }
            count++
        }

        count
    }
    println("P2: ${lcm(stepsTakenPerSource)}")
}

typealias Source = String
data class Node(val source: Source, val left: Source, val right: Source)

enum class Direction {
    LEFT,
    RIGHT
}

private fun gcd(a: Long, b: Long): Long {
    var a = a
    var b = b
    while (b > 0) {
        val temp = b
        b = a % b // % is remainder
        a = temp
    }
    return a
}

private fun lcm(a: Long, b: Long): Long {
    return a * (b / gcd(a, b))
}

private fun lcm(input: List<Long>): Long {
    var result = input[0]
    for (i in 1 until input.size) result = lcm(result, input[i])
    return result
}

private fun atFinishLine(currSpot: Node): Boolean {
    return currSpot.source.endsWith("Z")
}

private fun buildNetwork(lines: List<String>): Map<Source, Node> {
    val linePattern = """(\w+)\s*=\s*\((\w+),\s*(\w+)\)""".toRegex()
    return lines.subList(1, lines.size).fold(mutableMapOf()) { acc, line ->
        val (source, left, right) = linePattern.matchEntire(line)?.destructured!!
        acc[source] = Node(source, left, right)
        acc
    }
}


