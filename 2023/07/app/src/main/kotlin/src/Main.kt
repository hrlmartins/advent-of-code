/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

import java.math.BigInteger

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}

fun solveP1(lines: List<String>) {
    P1.solve(lines)
}

fun solveP2(lines: List<String>) {
    P2.solve(lines)
}

// TODO REFACTOR LATER :D.
// NO need for duplicate objects just a solver object that receives the points mapper and the hands translator to solve both days

object P1 {
    fun solve(lines: List<String>) {
        val cardHands = lines
                .filter { it.isNotEmpty() }
                .map { Hand(it.split(" ").first().trim(), it.split(" ").last().trim().toLong()) }

        val rankedCards =  cardHands.map { hand ->
            val mapCards = mutableMapOf<Char, Int>()
            hand.cards.forEach { card ->
                val currValue = mapCards.putIfAbsent(card, 1)
                currValue?.let { mapCards[card] = currValue + 1 }
            }
            rankedHand(mapCards, hand)
        }

        rankedCards.sorted().foldIndexed(0L) { index, acc, rankedHand ->
            val rank = index + 1
            acc + (rankedHand.hand.bid * rank)
        }.also { println("P1: $it") }
    }

    enum class HandType {
        HIGH_CARD,
        ONE_PAIR,
        TWO_PAIR,
        THREE_KIND,
        FULL_HOUSE,
        FOUD_KIND,
        FIVE_KIND,
    }

    val mapLetterPoints = mapOf(
            "T" to 10,
            "J" to 11,
            "Q" to 12,
            "K" to 13,
            "A" to 14
    )

    data class Hand(val cards: String, val bid: Long)
    data class RankedHand(val hand: Hand, val type: HandType): Comparable<RankedHand> {
        override fun compareTo(other: RankedHand): Int {
            if (this.type == other.type) {
                this.hand.cards.zip(other.hand.cards).forEach { (thisChar, otherChar) ->
                    val thisPoints = convertToPoints(thisChar)
                    val otherPoints = convertToPoints(otherChar)

                    if ((thisPoints - otherPoints) != 0) {
                        return (thisPoints - otherPoints)
                    }
                }

                return 0
            }

            return this.type.compareTo(other.type)
        }

    }

    private fun convertToPoints(char: Char): Int {
        return if (char.isDigit()) {
            char.toString().toInt()
        } else {
            mapLetterPoints[char.toString()]!!
        }
    }

    private fun rankedHand(mapCards: Map<Char, Int>, hand: Hand) =
            when (mapCards.size) {
                1 -> {
                    // can only be five of a kind
                    RankedHand(hand, HandType.FIVE_KIND)
                }
                2 -> {
                    // Can be four of a kind of full house
                    if (mapCards.values.any { it == 4 }) {
                        RankedHand(hand, HandType.FOUD_KIND)
                    } else {
                        RankedHand(hand, HandType.FULL_HOUSE)
                    }
                }
                3 -> {
                    // three of kind or two pair
                    if (mapCards.values.any { it == 3 }) {
                        RankedHand(hand, HandType.THREE_KIND)
                    } else {
                        RankedHand(hand, HandType.TWO_PAIR)
                    }

                }
                4 -> {
                    RankedHand(hand, HandType.ONE_PAIR)
                }
                else -> RankedHand(hand, HandType.HIGH_CARD)
            }
}

object P2 {
    fun solve(lines: List<String>) {
        val cardHands = lines
                .filter { it.isNotEmpty() }
                .map { Hand(it.split(" ").first(), it.split(" ").last().toLong()) }

        val rankedCards =  cardHands.map { hand ->
            val mapCards = mutableMapOf<Char, Int>()
            hand.cards.forEach { card ->
                val currValue = mapCards.putIfAbsent(card, 1)
                currValue?.let { mapCards[card] = currValue + 1 }
            }
            rankedHand(mapCards, hand)
        }

        rankedCards.sorted().foldIndexed(BigInteger.valueOf(0)) { index, acc, rankedHand ->
            val rank = index + 1
            acc.plus (BigInteger.valueOf(rankedHand.hand.bid * rank))
        }.also { println("P2: $it") }
    }

    enum class HandType {
        HIGH_CARD,
        ONE_PAIR,
        TWO_PAIR,
        THREE_KIND,
        FULL_HOUSE,
        FOUR_KIND,
        FIVE_KIND,
    }

    val mapLetterPoints = mapOf(
            "T" to 10,
            "J" to 1,
            "Q" to 12,
            "K" to 13,
            "A" to 14
    )

    data class Hand(val cards: String, val bid: Long)
    data class RankedHand(val hand: Hand, val type: HandType): Comparable<RankedHand> {
        override fun compareTo(other: RankedHand): Int {
            if (this.type == other.type) {
                this.hand.cards.zip(other.hand.cards).forEach { (thisChar, otherChar) ->
                    val thisPoints = convertToPoints(thisChar)
                    val otherPoints = convertToPoints(otherChar)

                    if ((thisPoints - otherPoints) != 0) {
                        return (thisPoints - otherPoints)
                    }
                }

                return 0
            }

            return this.type.compareTo(other.type)
        }

    }

    private fun convertToPoints(char: Char): Int {
        return if (char.isDigit()) {
            char.toString().toInt()
        } else {
            mapLetterPoints[char.toString()]!!
        }
    }

    private fun rankedHand(mapCards: Map<Char, Int>, hand: Hand) =
            when (mapCards.size) {
                1 -> {
                    // can only be five of a kind
                    RankedHand(hand, HandType.FIVE_KIND)
                }

                2 -> {
                    if (mapCards.values.any { it == 4 }) {
                        if (mapCards.containsKey('J')) {
                            RankedHand(hand, HandType.FIVE_KIND)
                        } else {
                            RankedHand(hand, HandType.FOUR_KIND)
                        }
                    } else {
                        if (mapCards.containsKey('J')) {
                            RankedHand(hand, HandType.FIVE_KIND)
                        } else {
                            RankedHand(hand, HandType.FULL_HOUSE)
                        }
                    }
                }

                3 -> {
                    if (mapCards.values.any { it == 3 }) {
                        if (mapCards.containsKey('J')) {
                            RankedHand(hand, HandType.FOUR_KIND)
                        } else {
                            RankedHand(hand, HandType.THREE_KIND)
                        }
                    } else {
                        if (mapCards.containsKey('J')) {
                            if (mapCards['J'] == 2) {
                                RankedHand(hand, HandType.FOUR_KIND)
                            } else {
                                RankedHand(hand, HandType.FULL_HOUSE)
                            }
                        } else {
                            RankedHand(hand, HandType.TWO_PAIR)
                        }
                    }

                }
                4 -> {
                    if (mapCards.containsKey('J')) {
                        RankedHand(hand, HandType.THREE_KIND)
                    } else {
                        RankedHand(hand, HandType.ONE_PAIR)
                    }
                }
                else -> {
                    if (mapCards.containsKey('J')) {
                        RankedHand(hand, HandType.ONE_PAIR)
                    } else {
                        RankedHand(hand, HandType.HIGH_CARD)
                    }
                }
            }
}
