/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}
fun solveP1(lines: List<String>) {
    // Build schematic representation
    // Two structures:
    //   One with numbers and all positions it occupies (can build list and map)
    //   Another with the symbols
    // Iterate the symbols and look in all numbers to check if it's adjacent

    val schema = buildSchematic(lines)
    val visited = mutableSetOf<Number>()

    val mapOfNumbers = schema.numbers.fold(mutableMapOf<Pair<Int, Int>, Number>()) { acc, number ->
        number.positions.forEach { acc[it] = number }
        acc
    }

    schema.symbols.sumOf { symbol ->
        val pos = symbol.position
        generatePositions(pos).sumOf { newPos ->
            mapOfNumbers.get(newPos)?.let {
                if (!visited.contains(it)) {
                    visited.add(it)
                    return@sumOf it.value
                }
            }

            0L
        }
    }.also { println("Sum of the machine parts: $it") }
}

fun solveP2(lines: List<String>) {
    val schema = buildSchematic(lines)

    val mapOfNumbers = schema.numbers.fold(mutableMapOf<Pair<Int, Int>, Number>()) { acc, number ->
        number.positions.forEach { acc[it] = number }
        acc
    }

    val relevantSymbols = schema.symbols.filter { it.value == "*" }

    relevantSymbols.sumOf { engineGear ->
        val pos = engineGear.position
        val visited = mutableSetOf<Number>()
        val count = generatePositions(pos).count { newPos ->
            mapOfNumbers.get(newPos)?.let {
                if (!visited.contains(it)) {
                    visited.add(it)
                    return@count true
                }
            }

            false
        }

        if (count == 2)  visited.fold(1L) { acc, number -> acc * number.value} else 0L
    }.also { println("The sum of ration gear is $it") }
}

data class Schema(val numbers: List<Number>, val symbols: List<Symbol>)
data class Symbol(val value: String, val position: Pair<Int, Int>)
data class Number(val value: Long, val positions: List<Pair<Int, Int>>)

private fun generatePositions(pos: Pair<Int, Int>): List<Pair<Int, Int>> {
    return listOf(
            Pair(pos.first + 1, pos.second),
            Pair(pos.first - 1, pos.second),
            Pair(pos.first, pos.second + 1),
            Pair(pos.first, pos.second - 1),
            Pair(pos.first + 1, pos.second + 1),
            Pair(pos.first - 1, pos.second - 1),
            Pair(pos.first - 1, pos.second + 1),
            Pair(pos.first + 1, pos.second - 1),
    )
}

private fun buildSchematic(lines: List<String>): Schema {
    val numbers = mutableListOf<Number>()
    val symbols = mutableListOf<Symbol>()

    lines.forEachIndexed { row, line ->
        var composeNumber = ""
        val listPosition = mutableListOf<Pair<Int, Int>>()
        var digitFlag = false

        line.forEachIndexed { col, character ->
            if (character.isDigit()) {
                composeNumber += character
                listPosition.add(Pair(col, row))
                digitFlag = true
            } else if (digitFlag && !character.isDigit()) {
                numbers.add(Number(composeNumber.toLong(), listPosition.toList()))
                digitFlag = false
                listPosition.clear()
                composeNumber = ""
            }

            if (!character.isDigit() && character != '.') {
                // tis a symbol
                symbols.add(Symbol(character.toString(), Pair(col, row)))
            }
        }

        if (composeNumber.isNotEmpty()) {
            // we are reading a number at the end of a line don't forget it!
            numbers.add(Number(composeNumber.toLong(), listPosition))
        }
    }

    return Schema(numbers.toList(), symbols.toList())
}