/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}

fun solveP1(lines: List<String>) {
    val nRows = lines.size
    val nCols = lines.first().length

    val matrix = Array(nRows) { CharArray(nCols) }
    val roundedRocks = processInput(nRows, nCols, matrix, lines)

    roundedRocks.forEach { rrock ->
        processNorthTilt(rrock, matrix)
    }

    matrix.foldIndexed(0L) { idx, acc, row ->
        acc + ((nRows - idx) * row.count { it == 'O' }.toLong())
    }.also { println("P1: $it") }
}


fun solveP2(lines: List<String>) {
    // Dont forget to recreate the list of rocks each tilt
    val nRows = lines.size
    val nCols = lines.first().length

    val matrix = Array(nRows) { CharArray(nCols) }
    var roundedRocks = processInput(nRows, nCols, matrix, lines)
    val pattern = mutableListOf<Pair<String, Array<CharArray>>>()
    var idxFound = -1
    run found@ {
        repeat((0 until 1000000000L).count()) { count ->
            roundedRocks = roundedRocks.map { rrock ->
                processNorthTilt(rrock, matrix)
            }.sortedBy { it.x }

            roundedRocks = roundedRocks.map { rrock ->
                processWestTilt(rrock, matrix)
            }.sortedBy { it.y }.reversed()


            roundedRocks = roundedRocks.map { rrock ->
                processSouthTilt(rrock, matrix)
            }.sortedBy { it.x }.reversed()

            roundedRocks = roundedRocks.map { rrock ->
                processEastTilt(rrock, matrix)
            }.sortedBy { it.y }

            if (pattern.indexOfFirst { it.first == toStringMatrix(matrix) } >= 0) {
                idxFound = pattern.indexOfFirst { it.first == toStringMatrix(matrix) }
                return@found
            } else {
                pattern.add(Pair(toStringMatrix(matrix), Array(nRows) { matrix.get(it).copyOf() }))
            }

        }
    }

    (0 until idxFound).forEach { pattern.removeFirst() }
    pattern.get((1000000000 - (idxFound + 1)) % pattern.size).second.foldIndexed(0L) { idx, acc, row ->
        acc + ((nRows - idx) * row.count { it == 'O' }.toLong())
    }.also { println("P2: $it") }
}

private fun toStringMatrix(matrix: Array<CharArray>): String {
    return matrix.joinToString { it.joinToString("") }
}

private fun processNorthTilt(rrock: Node, matrix: Array<CharArray>): Node {
    var currentRow = rrock.y
    var tmpRow = rrock.y - 1
    while (tmpRow >= 0 && matrix[tmpRow][rrock.x] == '.') {
        currentRow = tmpRow
        tmpRow--
    }
    // final position for this rock
    matrix[rrock.y][rrock.x] = '.'
    matrix[currentRow][rrock.x] = 'O'

    return Node(rrock.x, currentRow)
}

private fun processSouthTilt(rrock: Node, matrix: Array<CharArray>): Node {
    var currentRow = rrock.y
    var tmpRow = rrock.y + 1
    while (tmpRow < matrix.size && matrix[tmpRow][rrock.x] == '.') {
        currentRow = tmpRow
        tmpRow++
    }
    // final position for this rock
    matrix[rrock.y][rrock.x] = '.'
    matrix[currentRow][rrock.x] = 'O'

    return Node(rrock.x, currentRow)
}

private fun processWestTilt(rrock: Node, matrix: Array<CharArray>): Node {
    var currentCol = rrock.x
    var tmpCol = rrock.x - 1
    while (tmpCol >= 0 && matrix[rrock.y][tmpCol] == '.') {
        currentCol = tmpCol
        tmpCol--
    }
    // final position for this rock
    matrix[rrock.y][rrock.x] = '.'
    matrix[rrock.y][currentCol] = 'O'

    return Node(currentCol, rrock.y)
}

private fun processEastTilt(rrock: Node, matrix: Array<CharArray>): Node {
    var currentCol = rrock.x
    var tmpCol = rrock.x + 1
    while (tmpCol < matrix.first().size && matrix[rrock.y][tmpCol] == '.') {
        currentCol = tmpCol
        tmpCol++
    }
    // final position for this rock
    matrix[rrock.y][rrock.x] = '.'
    matrix[rrock.y][currentCol] = 'O'

    return Node(currentCol, rrock.y)
}


private fun processInput(nRows: Int, nCols: Int, matrix: Array<CharArray>, lines: List<String>): List<Node> {
    val roundedRocks = mutableListOf<Node>()

    (0 until nRows).forEach { y ->
        (0 until nCols).forEach { x ->
            matrix[y][x] = lines[y][x]
            if (lines[y][x] == 'O') {
                roundedRocks.add(Node(x, y))
            }
        }
    }

    return roundedRocks
}

private fun printMatrix(nRows: Int, nCols: Int, matrix: Array<CharArray>) {
    (0 until nRows).forEach { y ->
        (0 until nCols).forEach { x ->
            print(matrix[y][x])
        }
        println()
    }
}


data class Node(val x: Int, val y: Int)