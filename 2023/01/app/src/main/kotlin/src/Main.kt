/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}

fun solveP1(lines: List<String>) {
    val lineCodes = lines.map {
        // Digit only array string
        val digits = it.filter { c -> c.isDigit() }
        (digits.first().toString() + digits.last().toString()).toInt()
    }

    println("Sum calibration values: ${lineCodes.sum()}")
}

/*******
 *** P2
 *******/

data class DigitPosition(val digit: Int, val pos: Int)

fun solveP2(lines: List<String>) {
    val numberMap = mapOf(
            "one" to 1,
            "two" to 2,
            "three" to 3,
            "four" to 4,
            "five" to 5,
            "six" to 6,
            "seven" to 7,
            "eight" to 8,
            "nine" to 9
    )

    // Make indexof all possible ordinal numbers and numbers ordered by index
    // then compose the number. Associate the index with the digit already
    val lineCodes = lines.map {
        val ordinalDigitsPosition = numberMap.keys
                .flatMap { key ->
                    setOf(
                            DigitPosition(numberMap[key]!!, it.indexOf(key)),
                            DigitPosition(numberMap[key]!!, it.lastIndexOf(key))
                    )
                }
                .filter { digitPos -> digitPos.pos > -1 }

        val digitsPosition = it.mapIndexed { index, c ->
            if (c.isDigit()) DigitPosition(c.digitToInt(), index) else DigitPosition(-1, -1)
        }.filter { dp -> dp.pos > -1 }

        val jointDigits = (ordinalDigitsPosition + digitsPosition).sortedBy { dp -> dp.pos }

        (jointDigits.first().digit.toString() + jointDigits.last().digit.toString()).toInt()
    }

    println("Sum p2 calibration values: ${lineCodes.sum()}")
}