/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

fun main() {
    val input = generateSequence(::readLine).toList()
    solveP1(input)
    solveP2(input)
}

fun solveP1(lines: List<String>) {
    val nRows = lines.size
    val nCols = lines.first().length
    val matrix = createMatrix(lines)

    val visited = solve(matrix, nRows, nCols, mutableSetOf<VisitInfo>(), VisitInfo(Coords(0, 0), Direction.EAST))

    calcEnergized(visited).also { println("P1 $it") }
}

fun solveP2(lines: List<String>) {
    val nRows = lines.size
    val nCols = lines.first().length
    val matrix = createMatrix(lines)
    val values = mutableListOf<Int>()

    (0 until nRows).maxOf { y ->
        (0 until nCols).maxOf { x ->
            val listOfVisited = mutableListOf<Set<VisitInfo>>()
            if ( (x != 0 && y != 0) && (x != (nCols -1) && y != (nRows -1))) {
                return@maxOf 0
            }

            if (x == 0) {
                val altCoord = VisitInfo(Coords(x, y), Direction.EAST)
                listOfVisited.add(solve(matrix, nRows, nCols, mutableSetOf(), altCoord))
            }

            if (y == 0) {
                val altCoord = VisitInfo(Coords(x, y), Direction.SOUTH)
                listOfVisited.add(solve(matrix, nRows, nCols, mutableSetOf(), altCoord))
            }

            if (x == (nCols - 1)) {
                val altCoord = VisitInfo(Coords(x, y), Direction.WEST)
                listOfVisited.add(solve(matrix, nRows, nCols, mutableSetOf(), altCoord))
            }

            if (y == (nRows -1)) {
                val altCoord = VisitInfo(Coords(x, y), Direction.NORTH)
                listOfVisited.add(solve(matrix, nRows, nCols, mutableSetOf(), altCoord))
            }

            if (listOfVisited.isEmpty()) 0 else listOfVisited.map { calcEnergized(it) }.max()
        }
    }.also { println("P2 $it") }
}

private fun solve(matrix: Array<CharArray>, nRows: Int, nCols: Int, visited: MutableSet<VisitInfo>, current: VisitInfo): Set<VisitInfo> {
    visited.add(current)
    for (nextNode in generatePaths(current, matrix)) {
        if (!visited.contains(nextNode)) {
            solve(matrix, nRows, nCols, visited, nextNode)
        }
    }

    return visited
}

private fun calcEnergized(visited: Set<VisitInfo>): Int {
    return visited.fold(mutableSetOf<Coords>()) { acc, v ->
        acc.add(v.coords)
        acc
    }.size
}

private fun printVisitMatrix(visited: Set<VisitInfo>, matrix: Array<CharArray>) {
    val nRows = matrix.size
    val nCols = matrix.first().size

    (0 until nRows).forEach { y ->
        (0 until nCols).forEach { x ->
            if (visited.count { it.coords == Coords(x, y) } >= 1) {
                print("#")
            } else {
                print(matrix[y][x])
            }
        }
        println()
    }

    println()
}

private fun generatePaths(current: VisitInfo, matrix: Array<CharArray>): List<VisitInfo> {
    val curretPosValue = matrix[current.coords.y][current.coords.x]

    return when (curretPosValue) {
        '.' -> moveInCurrentDirection(current, matrix.size, matrix.first().size)
        '|' -> moveVerticalMirrorDirection(current, matrix.size, matrix.first().size)
        '-' -> moveHorizontalMirrorDirection(current, matrix.size, matrix.first().size)
        '/' -> moveInclinedRightMirrorDirection(current, matrix.size, matrix.first().size)
        '\\' -> moveInclineLeftMirrorDirection(current, matrix.size, matrix.first().size)
        else -> TODO()
    }
}

// this is the '\' tile
private fun moveInclineLeftMirrorDirection(current: VisitInfo, nRows: Int, nCols: Int): List<VisitInfo> {
    val inverseDir = when (current.dir) {
        Direction.NORTH -> Direction.SOUTH
        Direction.EAST -> Direction.WEST
        Direction.WEST -> Direction.EAST
        Direction.SOUTH -> Direction.NORTH
    }

    return moveInclinedRightMirrorDirection(VisitInfo(current.coords, inverseDir), nRows, nCols)
}

// this is the '/' tile
private fun moveInclinedRightMirrorDirection(current: VisitInfo, nRows: Int, nCols: Int): List<VisitInfo> {
    return when (current.dir) {
        Direction.NORTH -> {
            // Goes to east
            val newCoords = current.coords.copy(x = current.coords.x + 1)

            if (newCoords.x >= nCols) {
                listOf()
            } else {
                listOf(VisitInfo(newCoords, Direction.EAST))
            }
        }
        Direction.EAST -> {
            // goes to north
            val newCoords = current.coords.copy(y = current.coords.y - 1)

            if (newCoords.y < 0) {
                listOf()
            } else {
                listOf(VisitInfo(newCoords, Direction.NORTH))
            }
        }
        Direction.WEST -> {
            // goes to south
            val newCoords = current.coords.copy(y = current.coords.y + 1)

            if (newCoords.y >= nRows) {
                listOf()
            } else {
                listOf(VisitInfo(newCoords, Direction.SOUTH))
            }
        }
        Direction.SOUTH -> {
            // goes to west
            val newCoords = current.coords.copy(x = current.coords.x - 1)

            if (newCoords.x < 0) {
                listOf()
            } else {
                listOf(VisitInfo(newCoords, Direction.WEST))
            }
        }
    }
}

private fun moveHorizontalMirrorDirection(current: VisitInfo, nRows: Int, nCols: Int): List<VisitInfo> {
    return when (current.dir) {
        Direction.NORTH, Direction.SOUTH -> {
            val eastCoords = current.coords.copy(x = current.coords.x + 1)
            val westCoords = current.coords.copy(x = current.coords.x - 1)
            val nextVisits = mutableListOf<VisitInfo>()

            if (westCoords.x >= 0) {
                nextVisits.add(VisitInfo(westCoords, Direction.WEST))
            }

            if (eastCoords.x < nCols) {
                nextVisits.add(VisitInfo(eastCoords, Direction.EAST))
            }

            nextVisits

        }

        Direction.EAST, Direction.WEST -> moveInCurrentDirection(current, nRows, nCols)
    }
}


private fun moveVerticalMirrorDirection(current: VisitInfo, nRows: Int, nCols: Int): List<VisitInfo> {
    return when (current.dir) {
        Direction.NORTH, Direction.SOUTH -> moveInCurrentDirection(current, nRows, nCols)
        Direction.EAST, Direction.WEST -> {
            val northCoords = current.coords.copy(y = current.coords.y - 1)
            val southCoords = current.coords.copy(y = current.coords.y + 1)
            val nextVisits = mutableListOf<VisitInfo>()

            if (northCoords.y >= 0) {
                nextVisits.add(VisitInfo(northCoords, Direction.NORTH))
            }

            if (southCoords.y < nRows) {
                nextVisits.add(VisitInfo(southCoords, Direction.SOUTH))
            }

            nextVisits
        }
    }
}


private fun moveInCurrentDirection(current: VisitInfo, nRows: Int, nCols: Int): List<VisitInfo> {
    return when (current.dir) {
        Direction.NORTH -> {
            val newCoords = current.coords.copy(y = current.coords.y - 1)
            if (newCoords.y < 0) {
                listOf()
            } else {
                listOf(VisitInfo(newCoords, Direction.NORTH))
            }
        }
        Direction.EAST -> {
            val newCoords = current.coords.copy(x = current.coords.x + 1)
            if (newCoords.x >= nCols) {
                listOf()
            } else {
                listOf(VisitInfo(newCoords, Direction.EAST))
            }
        }
        Direction.WEST -> {
            val newCoords = current.coords.copy(x = current.coords.x - 1)
            if (newCoords.x < 0) {
                listOf()
            } else {
                listOf(VisitInfo(newCoords, Direction.WEST))
            }

        }
        Direction.SOUTH -> {
            val newCoords = current.coords.copy(y = current.coords.y + 1)
            if (newCoords.y >= nRows) {
                listOf()
            } else {
                listOf(VisitInfo(newCoords, Direction.SOUTH))
            }
        }
    }
}

data class Coords(val x: Int, val y: Int)
data class VisitInfo(val coords: Coords, val dir: Direction)
enum class Direction {
    NORTH,
    EAST,
    WEST,
    SOUTH
}

private fun createMatrix(input: List<String>): Array<CharArray> {
    val nRows = input.size
    val nCols = input.first().length

    val matrix = Array(nRows) { CharArray(nCols) }

    (0 until nRows).forEach { y ->
        (0 until nCols).forEach { x ->
            matrix[y][x] = input[y][x]
        }
    }
    return matrix
}
