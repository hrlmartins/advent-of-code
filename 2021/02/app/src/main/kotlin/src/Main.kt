/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src


fun main() {
    val input = generateSequence(::readLine).toList()

    // p1
    val sub = SubmarineWithAim(AutoPilotMovement())
    readInputAndFormat(input).forEach { sub.move(it) }
    println("The product of the position is: ${sub.position.depth * sub.position.horizontal}")

    // p2
    val sub2 = SubmarineWithAim(ManualPilotMovement())
    readInputAndFormat(input).forEach { sub2.move(it) }
    println("The product of the complex position is: ${sub2.position.depth * sub2.position.horizontal}")
}

//***********************************************************************************
// Domain Classes
//***********************************************************************************
enum class Direction {
    FORWARD,
    UP,
    DOWN
}

data class Movement(val direction: Direction, val value: Int)
data class Position(val horizontal: Int, val depth: Int, val aim: Int)

abstract class MovementRules {
    abstract fun move(movement: Movement, current: Position): Position
}
class AutoPilotMovement: MovementRules() {
    override fun move(movement: Movement, current: Position): Position {
        return when (movement.direction) {
            Direction.FORWARD -> current.copy(horizontal = current.horizontal + movement.value)
            Direction.DOWN -> current.copy(depth = current.depth + movement.value)
            Direction.UP -> current.copy(depth = current.depth - movement.value)
        }
    }
}
class ManualPilotMovement: MovementRules() {
    override fun move(movement: Movement, current: Position): Position {
         return when (movement.direction) {
            Direction.FORWARD -> {
                current.copy(
                    horizontal = current.horizontal + movement.value,
                    depth = current.depth + (movement.value * current.aim)
                )
            }
            Direction.DOWN -> current.copy(aim = current.aim + movement.value)
            Direction.UP -> current.copy(aim = current.aim - movement.value)
        }
    }
}

class SubmarineWithAim(val movementRules: MovementRules, var position: Position = Position(0, 0, 0)) {
    fun move(movement: Movement) {
        this.position = movementRules.move(movement, position)
    }
}

//***********************************************************************************
// Helpers
//***********************************************************************************
fun readInputAndFormat(input: List<String>): List<Movement> {
    val pattern = """(\w+) (\d+)""".toRegex()
    return input.map {
        val (direction, value) = pattern.matchEntire(it)?.destructured!!
        Movement(Direction.valueOf(direction.uppercase()), value.toInt())
    }
}
